本篇文章主要根据Chrome的调试工具（Devtool）中的Performance面板并结合简单的例子来探讨浏览器的运行原理，着重分析从DOM加载解析、JS执行到界面渲染的整个流程，还会包括事件循环（Event-Loop），不会深入探讨流程中的某个节点

>***Reference***
>[MDN 渲染页面：浏览器的工作原理](https://developer.mozilla.org/zh-CN/docs/Web/Performance/Guides/How_browsers_work?utm_source=chatgpt.com)
>
>[Chrome Devtools Performance features reference](https://developer.chrome.com/docs/devtools/performance/reference)
>
>[v8.dev bacground compilation](https://v8.dev/blog/background-compilation)

#### 项目概览
```text
├── eslint.config.js
├── index.html
├── package.json
├── pnpm-lock.yaml
├── public
│   └── vite.svg
├── README.md
├── src
│   ├── App.css
│   ├── App.tsx
│   ├── assets
│   │   └── react.svg
│   ├── index.css
│   ├── main.tsx
│   └── vite-env.d.ts
├── tsconfig.app.json
├── tsconfig.json
├── tsconfig.node.json
└── vite.config.ts
```

```json
// package.json
{
  "name": "buuuu",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^19.1.1",
    "react-dom": "^19.1.1"
  },
  "devDependencies": {
    "@eslint/js": "^9.33.0",
    "@types/react": "^19.1.10",
    "@types/react-dom": "^19.1.7",
    "@vitejs/plugin-react": "^5.0.0",
    "eslint": "^9.33.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.20",
    "globals": "^16.3.0",
    "typescript": "~5.8.3",
    "typescript-eslint": "^8.39.1",
    "vite": "^7.1.2"
  }
}
```

```tsx
// main.tsx
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)
```

```html
// index.html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root">abc</div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
```
#### 火焰图（flame chart）概览
![image](https://origin.picgo.net/2025/09/02/image3fb3b1ca3f59beaa.png)在火焰图中可以看出所有的JS执行、DOM解析、渲染、绘制等都是在火焰图的第一行**Task**基础之上运行的，这个**Task**就对应着**主线程**，也就是我们经常说的JS的核心特性**单线程模型**
#### 标记 Marks
在火焰图的底部会显示一些标记标签，这些标记代表某些阶段的开始或者结束
- **Nav** *navigation*  标识浏览器何时开始导航到一个新页面，加载流程的开端，通常出现在火焰图开始，标识本次页面加载或路由更改的起始点。在火焰图中可以看出*NAV*所对用的事件为0ms（火焰图中显示在NAV之前也有任务或者函数执行，这大概和chrome devtool的探针等有关，且此时时间轴为负数）
- **DCL** [*DOMContentLoaded Event*](https://developer.mozilla.org/docs/Web/API/Window/DOMContentLoaded_event) 这个节点表示此时HTML文档已被完全解析，此时并不包含图片、iframe异步脚本加载
- **L** [*Onload Event*](https://developer.mozilla.org/docs/Web/API/Window/load_event) 这个事件会在整个页面以及所有依赖资源，样式表和图片都已加载完成时触发
- **FP** [*First Paint*](https://developer.mozilla.org/docs/Glossary/First_paint) 界面渲染出第一个元素时的事件节点
- **FCP** [*First Contentful Paint*](https://web.dev/articles/fcp) 首屏渲染，这也是评估页面质量的重要指标之一
- **LCP** [*Largest Contentful Paint*](https://web.dev/articles/lcp) 这会包含窗口内可见的最大图片、文本块或视频的渲染事件（相对于用户首次导航到网页的时间）



#### DOC请求
![image](https://origin.picgo.net/2025/09/02/image95e6b3fe940dd428.png)
在Nav开始之后，浏览器会立马请求doc文档，值得注意的是这个请求并不是从主线程发出的（这是特例），可以理解为这个请求是用户“主动”发出。在请求完成之后才开始创建并运行主线程（~~猜想：只有当DOC文档请求成功且正确返回时才会运行主线程~~），但是在主线程开始运行之后从主线程中还会发送出一个对DOC文档`send request`的网络请求，但是在对应的`network`时间线中并没有看到有请求发出，暂时把这个特殊的加载叫做*伪请求*吧，猜测在主线程运行之前的doc加载完成之后会直接把*response*放到内存中，这里的伪请求则是会直接从内存当中读取数据。
#### 扫描&预加载
由于解析HTML会占用主线程，所以浏览器会在解析HTML之前对HTML内容进行预扫描，并且把可用的高优先级资源进行异步加载，在火焰图中的表现为`parseHTML`之前就会在主线程中创建网络请求，这样会减轻`parseHTML`所造成的阻塞
![image](https://origin.picgo.net/2025/09/02/imagee0e6975bede6d788.png)

#### 流式编译
![image](https://origin.picgo.net/2025/09/03/image6af30b91f865e33b.png)
浏览器的网络请求是在主线程中创建`send request`发出的，当有数据返回时就会向线程池中推一条名为`Streaming compile task`的任务（此时该任务所拿到的数据并不是接口返回的部分数据而非全量）这种流式在子任务中也有表现，在火焰图`Streaming compile task`的子任务中可以看到黄色部分`parse & compile`和灰色部分`Waiting for network`且`parse & compile`是分段的中间会穿插`Waiting for network`这就是"流式"的表现形式。
这个`parse & compile`任务呢主要负责对数据的解析和编译工作，把JS源代码**Parse**为AST，然后将AST编译为字节码或者机器码能够直接执行的指令
![image from v8.dev](https://v8.dev/_img/background-compilation/bytecode.svg)
其他非javascript资源在网络请求时也会创建一个这种`Streaming compile task`的任务，不过其子任务的`parse & compile`执行的就不是转为AST而是其他类型的
#### 页面渲染
由于火焰图中某个任务占用时间过长导致其他任务不能同时显示出来，所以用一个示意图表示解析&渲染过程的火焰图
![image](https://origin.picgo.net/2025/09/03/image297fe92de8cbd03a.png)
- 首先`parseHTML`，这个过程会解析HTML并构建**DOM树**，在构建DOM树的过程中浏览器会判断是否需要重新计算`style`或者布局，如果需要就会创建一个`Schedule style recalculation`的调度器，等待本次`parseHTML`执行完成后再开始执行`Recalculate Style`和`Layout`计算
	- 由于`parseHTML`会阻塞主任务，所以浏览器会把`parseHTML`分段执行作为优化项，边下载边“**流式解析**”，DOM树的构建是增量的
	- 其中`Schedule style recalculation`调度器执行效果很像`Vue`中的`Schedule`
- `Recalculate Style`浏览器会根据html文档或者已经下载下来的css文件构建**CSSOM**树，不过`CSS`规则是堆叠/继承的，因此`CSS`属于渲染阻塞资源，不可增量只能全量，在**CSSOM**树构建完成后浏览器会将**DOM树**和**CSSOM树**组合成**Render树**，**Render树**中只会包含页面上需要被渲染的节点，像是`<head>`标签，或者带有`display: none;`样式的节点，它们只会存在**DOM树**中，而不会被加入到**Render树**
- `Layout`浏览器会根据构建出来的**Render树**计算出盒子的几何信息，每个盒子的大小、位置等，计算得到**Layout树**，这一步也叫 **回流/重排（reflow）**
- `Paint`& `Layerize`在布局完成之后，浏览器会遍历**Layout树**，调用绘图API，将每个节点的可是内容绘制到一个或多个**Layer**图层中
- `commit`将上步生成的图层推到线程池中创建`Rasterize Paint`的任务，这个任务会调用GPU进行最终的绘制
![image](https://origin.picgo.net/2025/09/03/imaged229ac39e611b8cd.png)
#### ❌ 疑问
在`React`项目中，构建DOM树、CSSOM树和渲染相关任务为什么会运行在microtasks之上？这点违背了浏览器主线程的原理
![image](https://origin.picgo.net/2025/09/03/imageeba215374de247ae.png)
#### JS执行
此处分析一下HTML文档中引用的`main.tsx` `module`的执行过程：
![image](https://origin.picgo.net/2025/09/03/imagecdf286b1db7fa29e.png)
在DOM解析过程中解析到`<script type="module" src="/src/main.tsx"></script>`时，浏览器会在主线程上开启一个`Evaluate module`的任务来执行其中的JS代码，此时代码已经被编译为了机器码。
- JS代码会导致**DOM树**或者**CSSOM树**的修改因此会触发重新计算**Render树**等后续的渲染操作，例如`React`中执行`appendChild`触发dom更新，此时会创建一个`Schedule style recalculation`的子任务，我们可以把这个后续的构建xx树，渲染等操作看成宏任务，在火焰图中它们会被排到`microtasks`之后
![image](https://origin.picgo.net/2025/09/03/imagebb38e1020114d9b6.png)
- `setTimeout`我们在JS中写的定时器可以看作是创建了一个宏任务，插入到事件循环（主线程）中，在火焰图中看起来更加直观，放大`setTimeout`执行的部分可以看到会在主线程中开一个`Timer fired`的任务并在此任务中执行回调
![image](https://origin.picgo.net/2025/09/03/image4c992270c888a1d3.png)
![image](https://origin.picgo.net/2025/09/03/image3dc26ef9a9179329.png)
因此可以看出和页面渲染相关任务（例如：`parseHTML`,`Recalculate Style`,`Layout`,`paint`等）和`setTimeout`处于同一级别，都可以看作宏任务（Macrotasks）

关于**微任务**（Microtask）可以理解为伴随着JS代码执行所产生的一个特殊窗口，它会紧接着此次JS代码执行结束后开始执行
![image](https://origin.picgo.net/2025/09/03/image54dcc79202a73930.png)在火焰图中更容易看出在JS执行结束后会运行`Run microtasks`，我们可以把微任务的执行看作属于此次JS执行(Evaluate module)的一部分，因此在微任务中所创建的微任务属于此次执行过程，这样宏任务和微任务的执行顺序就很明了了，而且每一个`Run microtasks`之前必定会有个JS执行过程。
**垃圾回收**：浏览器的垃圾回收也指的是[[JS中的垃圾回收]]，在火焰图中的表现如下
![image](https://origin.picgo.net/2025/09/03/image0c45a2f9bb496524.png)
**用户操作**浏览器在监听到事件后（例如‘点击’操作）会在主线程中开启一个`Event:xxx`的任务且这个执行过程是由`Function Call`和`Run microtasks`一同组成的，可以看作是一个宏任务
![image](https://origin.picgo.net/2025/09/03/image50f296bb133970f4.png)
