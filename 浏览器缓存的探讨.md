缓存机制在浏览器中扮演着重要的角色，它能帮助浏览器节省带宽，加速页面加载，减少不必要的网络请求

#### header有关的缓存属性
关于浏览器的缓存控制都是在请求header中设置的属性
##### request header
###### Cache-Control
- `max-age=<seconds>` 资源在缓存中设置的最大缓存时间，如果过期则会向服务器重新获取
- `no-cache` 表示不会第一时间使用缓存资源，首先会向服务器验证缓存的有效性，再判断是否使用
- `no-store` 客户端请求不要缓存请求或响应（任何缓存都不应该存储）
- `no-transform` 禁止中间缓存对资源进行变形（如压缩、格式转换）
- `max-stale[=<seconds>]` 客户端愿意接受过期的响应，甚至接受过期 N 秒以上的内容
- `min-fresh=<seconds>` 客户端希望获取一个在接下来 N 秒内仍保持新鲜（fresh）的响应
- `only-if-cached` 仅当有缓存时响应请求，否则不请求服务器（通常配合 504 Gateway Timeout 响应）
###### If-None-Match
携带上一次请求`response`的`ETag`，用于协商缓存，服务器对比如果资源没有被修改则返回`304`
###### If-Modified-Since
携带上次服务器返回的`Last-Modified`时间，服务端会判断资源是否有变更，如果没有变更则返回`304`
##### response header
###### Cache-Control
- `max-age=<seconds>` 资源在缓存中的有效时间
- `s-maxage=<seconds>` 专用于共享缓存（如 CDN、代理），覆盖 max-age 的设置，对私有缓存无效
- `no-cache` 允许缓存资源，但必须在再次使用前向服务器验证（**协商缓存**）
- `no-store` 不允许任何缓存存储响应（用于敏感内容）
- `private` 只允许私有缓存（如浏览器）存储，不允许共享缓存存储
- `public` 允许所有缓存（包括共享缓存）存储响应，即使存在 Authorization 头也可（但默认情况下授权响应是不可共享的）
- `immutable` 对一些静态资源添加这个属性，意思是文件不会发生修改，即是在缓存有效期内，用户的一些操作也会导致跳过强缓存而直接向服务端发起缓存验证请求，而这个属性的存在会强制资源读取缓存而不会向浏览器发起验证请求，具体可以查看[[#浏览器操作对缓存的影响]]
###### Expires
HTTP/1.0 的过期时间，指定一个绝对时间点；如果同时存在 Cache-Control （带 max-age），则 max-age 优先
###### ETag
资源的唯一标识（通常为 hash 值），用于后续的条件请求比对
###### Last-Modified
资源最后修改时间，协商缓存时搭配 `If-Modified-Since` 使用
###### Vary
当服务器返回的资源因请求头不同而变化时，可使用这个头指示：缓存要区分请求头内容
#### 强缓存
浏览器在本地直接使用缓存资源，当缓存还未过期时会从硬盘或者是内存中读取，不会发起网络请求，控制强制缓存的缓存头有`Cache-Control`和`Expires`，且**强制缓存**的优先级高于**协商缓存**
#### 协商缓存
当无强缓存或者强缓存失效的情况下，会根据协商缓存字段response(ETag、Last-Modified)，request（If-None-Match、If-Modified-Since）由服务器判断缓存是否失效并把对比结果告知浏览器，或者直接返回有效资源
![image](https://origin.picgo.net/2025/09/10/imagee06634e105442a60.png)
#### 浏览器操作对缓存的影响
- *按F5进行普通刷新* 浏览器会在request header加上`Cache-Control: max-age=0`强制向浏览器发起缓存验证的请求，此时假如存储的缓存中有`immutable`属性（上次服务器返的response中有此属性），则请求会直接跳过缓存是否有效的验证，直接使用本地缓存
- *强制刷新*  此时会直接跳过浏览器的缓存机制，`immutable`属性，强缓存，协商缓存都将失效
- *地址栏回车，前进/后退等常规操作* 会遵循`max-age`的机制，强缓存->协商缓存
#### 缓存在浏览器的存储
存储方式采用**键值对**的形式，会把当前资源的`url`作为键值，对应缓存资源，但是在存储之前根据页面的域名进行**分区**，即每个域名下的界面都是独立分区，只有当分区和键名都对应上才会缓存命中，所以不同的网站（域名不同）下即是请求的资源相同（url相同）也不会使用同一个缓存
因此可以根据键值是`url`的属性在`url`末尾加上参数，造成缓存*强制失效*的现象，`url?version=${random}`
#### 浏览器的多级缓存
在使用chrome调试工具时我们经常看到当缓存命中时会从浏览器缓存中读取资源，而缓存资源存储的位置却不相同（from disk或者from memeory），这是和浏览器**多级缓存**是有关系的，关于多级缓存涉及到具体的算法，这里不再阐述，大致判断流程如下：首次访问网页时浏览器会从服务端加载资源，并把符合缓存条件的资源存储到硬盘中（这一步是必须的），然后会视情况将**符合条件**（优先保留最近频繁访问、体积小且能提升性能的资源在内存中）的资源提升到内存当中，如果关闭浏览器之后所有存储在内存中的缓存会消失，重新打开浏览器会从硬盘中读取缓存，然后浏览器会再次评估**符合条件**的资源并将其提升到内存当中。关于具体的缓存淘汰策略可以参考[WIKI Cache replacement policies](https://en.wikipedia.org/wiki/Cache_replacement_policies)

